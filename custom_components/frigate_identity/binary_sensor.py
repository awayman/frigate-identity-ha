"""Binary sensor platform for Frigate Identity.

Creates per-child supervision sensors that track whether a child is in the
same zone as a trusted adult.  Replaces the Jinja2 template binary sensors
previously generated by generate_dashboard.py.
"""
from __future__ import annotations

import logging
from datetime import datetime
from typing import Any

from homeassistant.components.binary_sensor import (
    BinarySensorDeviceClass,
    BinarySensorEntity,
)
from homeassistant.config_entries import ConfigEntry
from homeassistant.core import HomeAssistant, callback
from homeassistant.helpers.entity_platform import AddEntitiesCallback

from .const import DOMAIN
from .person_registry import PersonData, PersonRegistry, is_adult

_LOGGER = logging.getLogger(__name__)

# A child is considered supervised if an adult was seen within this many seconds
_SUPERVISION_TIMEOUT_SECONDS = 60


async def async_setup_entry(
    hass: HomeAssistant,
    config_entry: ConfigEntry,
    async_add_entities: AddEntitiesCallback,
) -> None:
    """Set up Frigate Identity supervision binary sensors."""
    registry: PersonRegistry = hass.data[DOMAIN]["registry"]
    tracked: dict[str, FrigateIdentitySupervisionSensor] = {}

    @callback
    def _on_persons_changed() -> None:
        """Create supervision sensors for newly discovered children."""
        adults = registry.adults()
        if not adults:
            return

        new_entities: list[FrigateIdentitySupervisionSensor] = []
        for child_name in registry.children():
            if child_name not in tracked:
                entity = FrigateIdentitySupervisionSensor(
                    child_name, adults, registry
                )
                tracked[child_name] = entity
                new_entities.append(entity)
        if new_entities:
            async_add_entities(new_entities)

    unsub = registry.register_listener(_on_persons_changed)
    config_entry.async_on_unload(unsub)

    # Create for already-known children
    _on_persons_changed()


class FrigateIdentitySupervisionSensor(BinarySensorEntity):
    """Binary sensor tracking whether a child is supervised by a trusted adult.

    Supervised = True when at least one adult is in the same resolved zone
    as the child and was seen within the timeout window.

    Zone resolution priority:
      1. camera_zones override from persons.yaml
      2. HA Area of the camera entity (if available)
      3. Camera name as fallback
    """

    _attr_has_entity_name = True
    _attr_device_class = BinarySensorDeviceClass.PRESENCE

    def __init__(
        self,
        child_name: str,
        adult_names: list[str],
        registry: PersonRegistry,
    ) -> None:
        """Initialise the sensor."""
        self._child_name = child_name
        self._adult_names = adult_names
        slug = child_name.lower().replace(" ", "_").replace("-", "_")
        self._attr_name = f"{child_name} Supervised"
        self._attr_unique_id = f"frigate_identity_{slug}_supervised"
        self._attr_is_on: bool | None = False
        self._attr_extra_state_attributes: dict[str, Any] = {
            "supervising_adult": None,
        }
        self._registry = registry
        self._unsub_listener: Any = None

    async def async_added_to_hass(self) -> None:
        """Start tracking supervision state."""

        @callback
        def _on_persons_changed() -> None:
            self._evaluate_supervision()

        self._unsub_listener = self._registry.register_listener(
            _on_persons_changed
        )
        self._evaluate_supervision()

    @callback
    def _evaluate_supervision(self) -> None:
        """Evaluate whether the child is currently supervised."""
        child = self._registry.get_person(self._child_name)
        if child is None or child.camera is None:
            self._attr_is_on = False
            self._attr_extra_state_attributes = {"supervising_adult": None}
            self.async_write_ha_state()
            return

        child_zone = self._resolve_zone(child.camera)
        now_ts = datetime.now().timestamp()
        supervising: str | None = None

        # Refresh adult list from registry (adults may have been added)
        current_adults = self._registry.adults()

        for adult_name in current_adults:
            adult = self._registry.get_person(adult_name)
            if adult is None or adult.camera is None or adult.last_seen is None:
                continue

            try:
                adult_seen_ts = datetime.fromisoformat(adult.last_seen).timestamp()
            except (ValueError, TypeError):
                continue

            if (now_ts - adult_seen_ts) > _SUPERVISION_TIMEOUT_SECONDS:
                continue

            adult_zone = self._resolve_zone(adult.camera)
            if adult_zone == child_zone:
                supervising = adult_name
                break

        self._attr_is_on = supervising is not None
        self._attr_extra_state_attributes = {
            "supervising_adult": supervising,
            "child_zone": child_zone,
        }
        self.async_write_ha_state()

    def _resolve_zone(self, camera_name: str) -> str:
        """Resolve a camera name to a supervision zone.

        Priority:
          1. camera_zones override from persons.yaml
          2. HA Area lookup for camera.<name> entity
          3. Camera name as fallback
        """
        # 1. Explicit override
        overrides = self._registry.camera_zones
        if camera_name in overrides:
            return overrides[camera_name]

        # 2. HA Area lookup
        try:
            entity_id = f"camera.{camera_name}"
            entity_reg = self.hass.data.get("entity_registry")
            if entity_reg is not None:
                entry = entity_reg.async_get(entity_id)
                if entry and entry.area_id:
                    area_reg = self.hass.data.get("area_registry")
                    if area_reg is not None:
                        area = area_reg.async_get_area(entry.area_id)
                        if area and area.name:
                            return area.name
        except Exception:  # noqa: BLE001
            _LOGGER.debug("Could not resolve area for camera.%s", camera_name)

        # 3. Fallback
        return camera_name

    async def async_will_remove_from_hass(self) -> None:
        """Clean up."""
        if callable(self._unsub_listener):
            self._unsub_listener()
